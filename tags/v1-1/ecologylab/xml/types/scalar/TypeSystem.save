package ecologylab.types;

import java.util.HashMap;
import java.lang.reflect.Field;

import ecologylab.xml.IO;

/**
 * This class builds a static type system.
 * The initial implementation maps each type name to an integer index.
 * It is expected that we will add functionality such as reverse lookup,
 * and the ability to instantiate types automatically.
 */
public class TypeSystem extends IO
implements BuiltinTypeIndices
{
/**
 * Maps Strings that represent classes to integers.
 * These integers, some of which are defined in the interface 
 * {@link BuiltinTypeIndices Types}. Type to integer mappings that are defined in
 * this class use positive integers. All other extended types should
 * use negative integers.
 */	
	private static final HashMap allTypes	  = new HashMap(32);
	
	static
	{
		addType("java.lang.String", TYPE_STRING);
		addType("int", TYPE_INT);
		addType("boolean", TYPE_BOOLEAN);
		addType("float", TYPE_FLOAT);
		addType("double", TYPE_DOUBLE);
		addType("long", TYPE_LONG);
		addType("short", TYPE_SHORT);
		addType("byte",  TYPE_BYTE);
		addType("char", TYPE_CHAR);
		addType("java.awt.Color", TYPE_COLOR);

//		mapTypeToInt("java.awt.Date", TYPE_DATE);
	}
	
/**
 * Assign an integer to a type. 
 * Used by setPrimitiveField().
 * <br/>
 * Type to integer mappings that are defined in
 * this class use positive integers. All other extended types should
 * use negative integers.
 * 
 * @param typeName		the String that represents the type's name
 * @param typeValue		the integer that represents the type's value
 * 
 * @return true if this is a new typeName
 * @return false if this new typeName was already assigned, in which case,
 * this method has no effect.
 */
	public static boolean addType(String typeName, int typeValue)
	{ 
		boolean result;
		synchronized (allTypes)
		{
			result	= !allTypes.containsKey(typeName);
			if (result)
				allTypes.put(typeName, new Integer(typeValue));
			else
				println("mapTypeToInt() ERROR! Cant redefine int mapping for "+
						  typeName);
		}
		return result;
	}

/**
 * @return integer representing the type associated with this typeName,
 * or TYPE_UNDEFINED if typeNameToIndexMap doesn't contain an entry.
 */
	public static final int getTypeIndex(Field field)
	{ 
		return getTypeIndex(field.getType());
	}
	
/**
 * @return integer representing the type associated with this typeName,
 * or TYPE_UNDEFINED if typeNameToIndexMap doesn't contain an entry.
 */
	public static final int getTypeIndex(Class thatClass)
	{
		return getTypeIndex(thatClass.getName());
	}
/**
 * @return integer representing the type associated with this typeName,
 * or TYPE_UNDEFINED if typeNameToIndexMap doesn't contain an entry.
 */
	public static int getTypeIndex(String typeName)
	{ 
		Integer typeIntegerObj	  = (Integer) allTypes.get(typeName);
		return (typeIntegerObj == null) ?
			TYPE_UNDEFINED :						 // no settable mapping for this type
			typeIntegerObj.intValue();
	}
}
